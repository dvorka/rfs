<HTML>
<!--  This Web page was created by Dvoøka  -->

<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1250">
<TITLE>Reliable File System</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#FF0000" VLINK="#0000FF" ALINK="#008000">
<FONT FACE="Courier New CE" SIZE="-1">

<BR>
<CENTER>
<FONT FACE="Courier New CE" COLOR="#0000FF">
<U><H1>Reliable File System</H1></U>
<BR>
<U><H2>Spodní vrstva</H2></U>
</FONT>
<BR>
Dokumentace: Martin Dvoøák
</CENTER>
<BR>
<BR>
<BR>

<U><FONT SIZE="+1" COLOR="#0000FF">Co by nemìlo ujít Vaší pozornosti:</FONT></U>
<CENTER>
<BR>
Srdce spodní vrstvy CacheMan - pro pochopení toho jak spodní vrstva funguje je nutné si proèíst kapitolu o nìm. <B>CacheMan je nositelem mazanosti cache</B>. CacheMan byl navren tak, aby horní vrstva <B>NEMUSELA vùbec LOGOVAT</B> a také se <B>nemusela v
ùbec starat o KONZISTENCI</B> - vše je v nìm zabudováno! <B>Cacheman je interfacem mezi spodní a horní vrstou - je poskytovatelem slueb.</B> Zásadní vıznam pro práci s ním má pojem package.
<BR>
<BR>
Další superdùleitou kapitolou je kapitola o <B>TRANSAKCÍCH</B> a <B>LOGOVÁNÍ</B>. Kdy u nic jiného tak tato kapitola ozøejmí proè nazıvat náš file system <B>RELIABLE</B>.
<BR>
<BR>
</CENTER>

<U><FONT SIZE="+1" COLOR="#0000FF">Examply</FONT></U>
<CENTER>
<BR>
Examply, které pøedvádìjí spodní vrstvu jsou tyto projekty:
<BR>
example1.prj, ( main v EXAMPLE1.LOW ) - <B>vytvoøení diskù, oblastí, formátování</B>
<BR>
example2.prj, ( main v EXAMPLE2.LOW ) - <B>dva examply na fungování CacheMana</B>
<BR>
example3.prj, ( main v EXAMPLE3.LOW ) - <B>transakce, logy a recovery spodní vrstvy</B>
<BR>
example4.prj, ( main v EXAMPLE4.LOW ) - <B>striping a záchrana disku</B>
<BR>
<BR>
Všechny informace k tomu kterému examplu jsou v jeho main.cpp. Tam najdete co example provádí, co máte udìlat...
<BR>
<BR>
</CENTER>

<U><FONT SIZE="+1" COLOR="#0000FF">Obsah</FONT></U>

<UL>
 <LI>
 <A HREF="#AnchorSchema">Schema spodní vrstvy file systému</A>
 </LI>

 <LI>
 <A HREF="#AnchorStrukturaDat">Struktura dat na disku</A>
 <UL>
  <LI>
   <A HREF="#AnchorMBR">Master Boot Record</A>
  </LI>
  <LI>
   <A HREF="#AnchorBR">Boot Record</A>
  </LI>
  <LI>
   <A HREF="#AnchorTheSecondBR">The Second Boot Record</A>
  </LI>
  <LI>
   <A HREF="#AnchorStatistika">Statistika grup</A>
  </LI>
  <LI>
   <A HREF="#AnchorOblast">Oblast ( myšlena partition )</A>
  </LI>
  <LI>
   <A HREF="#AnchorGrupy">Grupy</A>
  </LI>

 </UL>
 </LI>

 <LI>
 <A HREF="#AnchorFyzickeChyby">Fyzické chyby media a jak jsme se s nimi vyrovnali</A>
 </LI>
 <LI>
 <A HREF="#AnchorStriping">Striping</A>
 </LI>
 <LI>
 <A HREF="#AnchorCacheMan">CacheMan = Cache + Swap, package, konzistentní zápisy</A>
 <UL>
  <LI>
   <A HREF="#AnchorCteni">Ètení</A>
  </LI>
  <LI>
   <A HREF="#AnchorZapis">Zápis</A>
  </LI>
  <LI>
   <A HREF="#AnchorVelikostCache">Velikost cache, swapovací oblasti</A>
  </LI>
  <LI>
   <A HREF="#AnchorCommit">Commit package</A>
  </LI>
  <LI>
   <A HREF="#AnchorJineMoznosti">Byly tu i jiné monosti...</A>
  </LI>
 </UL>

 </LI>
 <LI>
 <A HREF="#AnchorTransakce">TRANSAKCE a LOGY : *.ALF, *.NOT, *.OKA, *.HLP, *.CML</A>
 <UL>
  <LI>
   <A HREF="#AnchorALF">*.ALF - ALLOC/FREE log</A>
  </LI>
  <LI>
   <A HREF="#AnchorNOT">*.NOT - NOT PackageID Alloc/Free log</A>
  </LI>
  <LI>
   <A HREF="#AnchorOKA">*.OKA - OK Allocated/Released log</A>
  </LI>
  <LI>
   <A HREF="#AnchorHLP">*.HLP - HeLP Alloc/Free undo log</A>
  </LI>
  <LI>
   <A HREF="#AnchorCML">*.CML - Commit undo/redo log</A>
  </LI>
 </UL>
 </LI>


  <LI>
   <A HREF="#AnchorOpenFs">Co se dìje pøi inicializaci RFS...</A>
  </LI>
  <LI>
   <A HREF="#AnchorRecovery">RECOVERY aneb jak se opravuje pomocí logù po pádu systému</A>
  </LI>
  <LI>
   <A HREF="#AnchorShutdownFs">Co se dìje pøi zavírání RFS...</A>
  </LI>
</UL>

<BR>

<A NAME="AnchorSchema"><U><FONT SIZE="+1" COLOR="#0000FF">Schema spodní vrstvy file systému</FONT></U></A>
<BR>
Jak ji bylo zmínìno interfacem mezi horní a spodní vrstvou je Cacheman. Horní vrstva volá pøi obvyklé práce vlastnì pouze jeho funkce. Ty jsou dekladrovány v <A HREF="../cacheman.h">CACHEMAN.H</A>
<CENTER>
<IMG SRC="lowschm.gif" BORDER=0>
</CENTER>
<BR>
<BR>

<A NAME="AnchorStrukturaDat"><U><FONT SIZE="+1" COLOR="#0000FF">Struktura dat na disku</FONT></U></A>
<BR>
<BR>
<CENTER>
<IMG SRC="lowlevel.gif" WIDTH=589 HEIGHT=169 BORDER=0>
</CENTER>
<BR>
Nyní podrobnìji k jednotlivım strukturám...
<BR>
<BR>

<A NAME="AnchorMBR"><U><FONT COLOR="#0000FF">Master Boot Record</FONT></U></A>
<BR>
Master boot record má klasickı formát. Jeho velikost je 1 sektor == 512B. Vyhrazena je pro nìj ale celá první stopa. Pro vìtší bezpeènost pøi kadé zmìnì MBR duplikujeme jeho obsah do všech sektorù první stopy. V pøípadì havárie tedy mùe záchranná utili
ta s velkou pravdìpodobností MBR restaurovat.
<BR>
Formát Master boot recordu je deklarován v <A HREF="../fstypes.h">FSTYPES.H</A>
<BR>
<BR>

<A NAME="AnchorBR"><U><FONT COLOR="#0000FF">Boot Record</FONT></U></A>
<BR>
Zabírá jeden sektor. Obsahuje klasické informace. Struktura ne nepodobná MBR. Oproti MBR obsahuje informace dùleité pro oblast:
<UL>
<LI>Dirty flag oblasti: je TRUE pokud oblast nebyla èistì uzavøena. Tento flag se kontroluje pøi startu systému. Pokud je oblast dirty nastartuje se záchranná a kontrolní utilita. Pøi uzavírání systému se nastavuje na FALSE.</LI>
<LI>Adresa FNODU root recordu v oblasti ( adresa logická, relativní od zaèátku oblasti ).</LI>
<LI>Poèet grup v oblasti.</LI>
<LI>...</LI>
</UL>
<BR>
Formát Boot recordu je deklarován v <A HREF="../fstypes.h">FSTYPES.H</A>
<BR>
<BR>

<A NAME="AnchorTheSecondBR"><U><FONT COLOR="#0000FF">The Second Boot Record</FONT></U></A>
<BR>
Je rozšíøením + èásteènou zálohou Boot Recordu. Obsahuje kopii BIOS parametr bloku
boot recordu -&gt; ten obsahuje nejdùleitìjší informace dùleité pro orientaci v oblasti
( bez nich se to dá v podstatì zabalit ).  Dále obsahuje statistické informace jako: poèet volnıch sektorù v oblasti, poèet sektorù se statistikou grup ( viz níe ), duplikát poètu grup v oblasti, label oblasti. The Second Boot Record není bezpodmínìènì
nutnı pro bìh RFS. Informace z nìj vyuívají funkce pro alokace/dealokace sektorù. Jeho vıpadek není fatální.
<BR>
Formát The Second Boot recordu je deklarován v <A HREF="../fstypes.h">FSTYPES.H</A>
<BR>
<BR>

<A NAME="AnchorStatistika"><U><FONT COLOR="#0000FF">Statistika grup</FONT></U></A>
<BR>
Je to oblast nìkolika sektorù, která udruje informaci o tom kolik je v kadé grupì v oblasti volnıch sektorù ( Word ). Kadı sektor tedy obsahuje informace o 512/2  grupách, poèet statistickıch sektorù se øídí poètem grup. Tyto statistiky jsou spravován
y a vyuívány funkcemi CacheManAllocateSector a CacheManFreeSector z <A HREF="../cacheman.h">CACHEMAN.*</A>. Funkce statistiku pouívají napø. pro rychlé vytypování grupy pro alokaci.
<BR>
<BR>

<A NAME="AnchorOblast"><U><FONT COLOR="#0000FF">Oblast ( myšlena partition )</FONT></U></A>
<BR>
Oblasti jsou èíslovány od 1 do 4. Vytváøení se provádí pomocí funkcí z <A HREF="../fdisk.h">FDISK.H</A>
<BR>
<BR>

<U>Limity uvnitø jedné oblasti:</U>
<BR>
<B>Datová kapacita grupy v sektorech:</B> 12b sektorù ... 4k * 512B = 2MB
<BR>
<B>Poèet grup v oblasti:</B> 20b ... 1M grup
<BR>
<B>Velikost grupy:</B> 4k datovıch sektorù + 1 sektor bitmapa
<BR>
<B>Maximální adresovatelná velikost FS:</B> 32b sektorù ... 4,3M * 512B = 2,2TB neboli 1M grup * 2MB velikost grupy = 2,2TB
<BR>
<BR>


<A NAME="AnchorGrupy"><U><FONT COLOR="#0000FF">Grupy</FONT></U></A>
<BR>
Data v oblastech jsou organizována v grupách.

<UL>
<LI>
Grupa se skládá z bitmapy ( 1 sektor )a datovıch sektorù ( 4096=512*8 sektorù ). Bitmapa informuje o obsazení sektorù v grupì: BIT: 1..sektor je volnı, 0..sektor je plnı. Umístìna je u sudıch grup na poèátka a u lichıch na konci =&gt; tím vzniká souvislı
 datovı prostor délky 4MB.
<BR>
<CENTER>
<IMG SRC="group4m.gif" WIDTH=62 HEIGHT=78 BORDER=0>
</CENTER>
</LI>

<LI>
Èísla tıkající se grup:
<BR>
Datová kapacita grupy v sektorech: 12b sektorù ... 4k * 512B = 2MB
<BR>
Poèet grup v oblasti: 20b ... 1M grup
<BR>
Velikost grupy: 4k datovıch sektorù + 1 sektor bitmapa
</LI>

<LI>
Poslední grupa v oblasti vyjde zpravidla neúplná. Pøi formátování ji vytvoøím - vytvoøím hlavièku, verify sektory, do hlavièky poznaèím sektory které v grupì chybí ( za koncem oblasti ) jako plné. Pozdìji ji tedy lze pouít. Nyní je, ale implementace tak
ová, e se poslední grupa nepouívá vùbec. Proè ji nepouívám:
<OL>
<LI>
Pøi kadém zápisu èi ètení musí bıt test zda to není poslední grupa. Do té se pøistupuje jinak - a lichá èi sudám má bitmapu vdy na poèátku - velmi to zpomalovalo.
</LI>
<LI>
mùe mít velikost do 1 do 4096 sektorù a tak se mi mùe stát, e budu mít pouze sektor na bitmapu. Kdybych ji chtìl pouívat na nìjaké servisní informace opìt nevím co vše by se tam dalo uloit.
</LI>
</OL>

</LI>


<LI>
Jak se vyrovnávám s BADSEKTORY...
<UL>
<LI>
Vyskytnou-li se pøi formátování: sektor se oznaèí v hlavièce bitmapy jako zaplnìnı. Vyšší vrstva si ho nealokovala ... nemùe tedy o nìj poádat a niší vrstva si myslí, e je plnı a tak ho nikomu nedá ... tak se sektor nepouívá.
</LI>
<LI>
Vyskytnou-li se za bìhu: øeknu vyšší vrstvì, e sektor se nepodaøilo zapsat a já ho oznaèím jako plnı. Vyšší vrstva u to vyøídí ( pokusí se sektor zapsat jinam: naalokuje si jinde místo a zapíše ho tam ). Kdy to nastane pøi readu postupuje se obdobnì p
ouze nahoru dodám co jsem na tøikrát pøeèetl ( vìtšina bude asi špatnì protoe CRC nesedlo, ale je lepší dodat nìco ne nic ).
</UL>
</LI>





<LI>
Co se tıèe alokace sektorù v grupì:
<UL>

<LI>
Vyšší vrstva má monost si øíci za kterım sektorem a v které grupì má alokovaná oblast zaèínat - spodní vrstva se jí snaí vyhovìt ( CacheManAllocateSector() <A HREF="../cacheman.h">CACHEMAN.H</A> ).
</LI>

<LI>
<U>PØEDALOKOVÁVÁNÍ</U> nechávám na vyšší vrstvì - ta si øekne o víc ne chce a já jí takovou oblast dodám ( sám však nevím, jestli všechno vyuije nebo si syslí do budoucnosti ).
</LI>

<LI>
<U>HLEDÁNÍ GRUPY VHODNÉ PRO ALOKACI:</U> k dispozici je statistika zaplnìní celé oblasti + jednotlivıch grup ( viz. vıše ). Pokud caller specifikoval, kde by mìla alokovaná oblast zaèínat tak skouším hledat od tohoto sektoru v grupì dále. Pokud nic nenaj
du prohledám grupu od zaèátku a po specifikované místo. Pokud neuspìji ani teï hledám v následující grupì ( a tak eventuelnì projdu všechny grupy oblasti ). Pøi hledání se hojnì vyuívají statistiky ( ne naètu bitmapu grupy ze statistiky zjistím zda to
 má vùbec smysl).
<BR>
Pokud caller nespecifikoval, kde má alokovaná oblast zaèínat - vystøelím do grup náhodnì. A pak pøi hledání postupuji vıše uvedenım zpùsobem. Funguje to celkem spolehlivì. Dùvod proè to provádím je ten, e se file system zaplòuje rovnomìrnì ( nealokuje s
e od poèátku - data jsou roztroušena po disku ) a tak se sniuje pravdìpodobnost fragmentace. Jakmile je místa ménì, tak procházím statistiku a hledám podle ní. Velikosti dìr v grupách si nepamatuji. Udrování takové informace by bylo jak èasovì tak pamì
ovì velmi nároèné a podle mého názoru by se to ve vısledku ani nevyplatilo. Já v nejhorším pøípadì musím navštívit více grup. Díky alokaèní strategii uvedené vıše a statistikám se docela slušnì orientuji a souvislé prázdné oblasti se zpravidla najdou. S
e zaplòováním filesystemu se vše samozøejmì zpomaluje.
<BR>
Alokace provádí funkce CacheManAllocateSector() z <A HREF="../cacheman.h">CACHEMAN.H</A> ).
</LI>
</UL>

</LI>

<LI>
Co grupy daly a co vzaly...
<UL>
<LI>
  <IMG SRC="plus.gif" WIDTH=26 HEIGHT=25 BORDER=0> Data jsou soustøedìna více u sebe. Grupy jsou menší a tak pokud ztratíme jednu grupu nepøijdeme o tolik informací.
 </LI>
 <LI>
  <IMG SRC="plus.gif" WIDTH=26 HEIGHT=25 BORDER=0> Pouití grup umonilo zvolit jako alokaèní jednotku sektor ( ve smyslu úspornosti reijních informací ) a tím se zmenšil slack space.
 </LI>
 <LI>
 <IMG SRC="minus.gif" WIDTH=26 HEIGHT=25 BORDER=0> Udrování grup = bitmap nìco stojí.
 </LI>
</UL>
</LI>

</UL>

Funkce pro práci s grupami jsou deklarovány v <A HREF="../group.h">GROUP.H</A>,  deklarece fcí provádìjících alokace a dealokoce sektorù v <A HREF="../cacheman.h">CACHEMAN.H</A> implementace je v <A HREF="../allocfre.cpp">ALLOCFRE.CPP</A>.
<BR>
<BR>

<BR>

<A NAME="AnchorFyzickeChyby"><U><FONT SIZE="+1" COLOR="#0000FF">Fyzické chyby media a jak jsme se s nimi vyrovnali </FONT></U></A>
<BR>
Velikosti postiené oblasti: chyby bitové, bytové jsme se rozhodli na úrovni filesystemu neošetøovat. Vyuívat budeme hardwarového zabezpeèení. Kadı disk má za sektorem 32 bitovı ECC èásteènì samoopravnı kód. Je tedy zbyteèné zajišovat data lepším kóde
m apod. Menší chyby bitového rázu ( tuším do 4B ) by tedy mìl opravit hardware.
<BR>
<BR>

<A NAME="AnchorStriping"><U><FONT SIZE="+1" COLOR="#0000FF">Striping</FONT></U></A>
<BR>
        My jsme se rozhodli pro ochranu na úrovni sektorù a to metodou STRIPINGU. Data jsou na discích rozloena takto:
<BR>
<CENTER>
<IMG SRC="strpblk.gif" WIDTH=325 HEIGHT=236 BORDER=0>
</CENTER>
<BR>
Jak je vidìt tak díky rozloení dat mùou disky fungovat absolutnì nezávisle na sobì.
<BR>
<BR>
        Data NEjsou jako u ostaních systémù RAID rozloena tak, e následující blok je na následujícím disku. Takovı systém je sice tolikrát rychlejší ne 1 disk kolik je v nìm diskù ( 5 diskù - 5*rychlejší operace (èistì teoreticky)), ale má to bezpeèno
stní nevıhody. Disk nemùe fungovat samostatnì protoe data jsou rozloena + pokud dojde k vıpadku více ne dvou diskù je konec protoe data všech ostatních diskù nedávají smysl - jsou kompletnì ztracena.
<BR>
<BR>
        Naše uloení dat je MÉNÌ vıkonné, ale je mnohem bezpeènìjší. Kadı disk je autonomní, má svoje data na ostatních nezávislá. Mùe fungovat jak sám tak ve strivacím systému - striping se mùe zapínat/vypínat po pøebootování. Je to vlastnì tak, e k
dy máte v poèítaèi dva disky, mùete tam pøidat paritní, zapnout striping file sytemu a od té chvíli jedete bezpeènì. Pak paritní disk vyndáte a systém funguje dál. Nejvìtší pøínos stripingu v tomto modelu je ten, e pokud se vyskytne na nìkterém z dato
vıch diskù badsektor o data nepøijdete, protoe ty se pomocí parity dopoètou.
<BR>
<BR>
Vlastnosti:

<UL>
<LI>
stripovací jednotka je oblast - nemusí to tedy bıt celı fyzickı disk. Swapovací oblasti tedy nepodléhají stripingu a systém zbyteènì nebrzdi.
</LI>

<LI>
stripovací oblasti musí bıt stejnì velké
</LI>

<LI>
stripovacích datovıch oblastí mùe bıt teoreticky libovolnı poèet ( paritì je to jedno ).
</LI>

<LI>
overhead: (1/poèet datovıch diskù+1)*100 procent. Èím více diskù, tím menší overhead.
</LI>

<LI>
pøi vıpadku jednoho z datovıch diskù se dopoète jeho obsah z ostatních datovıch diskù a disku paritního.
</LI>

<LI>
pøi vıpadku paritního disku se nikam nepoèítá parita - systém je bez zabezpeèení.
</LI>

<LI>
vıpadek 2 a více diskù. Vypadá to sice nepravdìpodobnì, ale stát se to mùe. Disky mohou zaèít fungovat oddìlenì. Obsah 2 diskù je ztracen, obsah ostatních diskù je zachován.
</LI>

<LI>
BADSECTORY na discích a jejich souvislost se stripingem.
<UL>
 <LI>
 BADSECTOR na datovém disku: obsah sektoru se dopoète z ostatních datovıch diskù a  disku paritního. Do vyšší vrstvy se ohlásí, e se sektorem nelze pracovat, ale e data byla zachránìna. Opravená data se pošlou do vyšší vrstvy, v bitmapì se sektor oznaè
í jako full. Parita se nyní poèítá tak, e pokud sektor nelze pro vıpoèet parity pøeèíst, nahradí se pro vıpoèet jeho obsah 0x000... a takto se parita vypoète.
 </LI>
 <LI>
BADSECTOR na paritním disku. Celé patro ( datové sektory ze kterıch se parita poèítala ) se postupnì musí prohlásit za neplatné. Prázdné sektory se oznaèí jako full a poznaèí se, e jsou bad ( i kdy to není pravda ). Pouité sektory: kdykoli si vyšší vr
stva øekne o data z tohoto levelu, ohlásí se, e datovı SEKTOR je bad ( i kdy to není pravda ) a e data byla zachránìna. Tím se postupnì data z postieného levelu pøesunou jinam.
<BR>
Nic lepšího jsem nevymyslel. Podle mého názoru je nesmysl po vıpadku paritního sektoru dohledávat, kterému filu sektor patøí a pøealokovávat ho - to by bylo èasovì neúnosné. Takto se ale mùe stát, e se nepouívané sektory nepøesunou.
 </LI>
</UL>

</LI>
</UL>
<BR>
<BR>


<U><FONT COLOR="#0000FF">Reijní struktury</FONT></U>
<BR>
Struktury, které drí seznam stripovanıch oblastí, stav stripingu a vùbec vše dùleité co se ho tıká jsou deklarovány v <A HREF="../cachesup.h">CACHESUP.H</A>.
<BR>
<PRE>
 //---------------------------------------------------------------------------------
 //- STRIPING STRUCTURES - STRIPING STRUCTURES - STRIPING STRUCTURES -
 //---------------------------------------------------------------------------------

 struct _StripItem : PriQueueItem
 {
  byte  Device;
  byte  Party;
  dword Begin;  // logical HD sector 0..
  dword End;    // logical HD sector 0..
  dword Number; // End-Begin+1 ( data devices )
  byte  Type;   // PARITY_STRIP || DATA_STRIP - used for table on disk
 };

 typedef struct far _StripItem StripItem;



 class far DataStripsQueue : public PriQueue
 {
  public:

   DataStripsQueue( void ):PriQueue() { return; };
    void      Insert( StripItem far *Item  );

    StripItem far *FindFirstParty( void );
    StripItem far *FindNextParty( StripItem far *Actuall );
    bool      IsInStripingArea( byte Device, dword Logical );
    void      Show( void );
    word      DeleteParty( byte Device, byte Party );

    word      WriteSingleTable( byte Device, byte Party );
    word      WriteTablesToPartys( void );
              // these two functions would be methods of StripSession
              // but here is easier implementation

    bool      IsStriped( byte Device, byte Party ); // checks ParityHD too
    word      WriteSingleOffTable( byte Device, byte Party );
    word      WriteOffTablesToPartys( DataPartysQueue far * DirtyDataPartys );

   ~DataStripsQueue();
 };



 struct far _StripSession
 {

  byte StripingIs;              // ON / OFF

  DataStripsQueue DataHDs;      // data HDs queue

  StripItem       ParityHD;     // parity HD

 };

 typedef struct far _StripSession StripSession; // static structure in stripe.cpp
</PRE>
<BR>
Struktura StripSession obsahuje flag zapnutí / vypnutí stipingu a frontu deskriptorù stripovanıch oblastí a deskriptor paritní oblasti. Jak si mùete všimnout v deskriptorech, striping se orientuje podle logickıch sektorù na device ( nikoli na partyšnì )
. Deskriptory jsou také pouívány jako poloky stripovacích tabulek na disku.
<BR>
<BR>



<U><FONT COLOR="#0000FF">Inicialize stripingu</FONT></U>
<BR>
Následuje popis toho co se dìje pøi startu systému se stripingem. Implementace je v <A HREF="../striping.cpp">STRIPING.CPP</A>, co která funkce dìlá poznáte podle názvu nebo podle komentáøe pod hlavièkou v místì implementace funkce.
<BR>
<BR>
<B>Algoritmus:</B>
<BR>
1) Pøedchozími operacemi jsou v pamìti pøipraveny fronty CLEAN a DIRTY oblastí ( ve funkci FSOpenFileSystem() z <A HREF="../init.cpp">INIT.CPP</A> ) . Nyní se nacházím  ve funci InitializeStriping() <A HREF="../striping.cpp">STRIPING.CPP</A>.
<BR>
2) Beru oblast po oblasti a hledám na nich konfiguraèní tabulky stripingu.
<BR>
3) Vezmu tedy z fronty první dosud nezkontrolovanou oblast. Pokud jsou všechny oblasti zkontrolovány GOTO 8)
<BR>
4) Pokud na ní tabulka neexistuje beru z fronty další oblast GOTO 3). Pokud tabulka existuje GOTO 5)
<BR>
5) Provede se analıza tabulky. Pokud je v ní "striping on this device OFF" GOTO 3) jinak GOTO 6)
<BR>
6) Je to první nalezená tabulka? ANO - uloím si ji do speciálního bufferu. NE  - porovnám ji s první nalezenou tabulkou a nastavím si podle toho flag FOUNDED_TABLES_ARE_SAME ( TRUE/FALSE ).
<BR>
7) Všechny tabulky byly naèteny. Nyní se podle první naètené tabulky testuje, které oblasti z ní skuteènì existují a které v systému nejsou. Pokud oblast je uvedena v tabulce a v systému není zvıši se poèítadlo mrtvıch oblastí ( Dead++ a zapamatuje se ty
p oblasti )
<BR>
8) Dead==0 a tabulky stejné - striping se nahodí v normálním módu - KONEC
<BR>
9) Dead==1 a typ mrvé oblasti je RFSData -  nahodí se rescue utilita, která provede záchranu ztracené oblasti do oblasti jiné. Viz. níe. Po této akci se ještì nahodí rekonfiguraèní utilita, kde má uivatel monost ještì session doladit. Po rekonfiguraci
 - KONEC.
<BR>
10) Dead&gt;=2 nic nelze zachránit. Dvì a více mrtvıch oblastí to je moc. Jediné co zbıva je rekonfigurace sešny. Po rekonfiguraci - KONEC.
<BR>
<BR>


<U><FONT COLOR="#0000FF">Setup utility</FONT></U>
<BR>
Konfiguraèní mód se nabídne uivateli pøi startu systému. V nìm má monost pøidávat, ubírat a mìnit seznam oblastí na kterıch bude striping probíhat. Striping zde lze zapnout/vypnout. Lze také vypsat informace o jednotlivıch oblastech. Po aktualizaci sez
namu se provede pøepoèet parity na paritním disku ( pokud je striping zapnut ).
<BR>
<BR>


<U><FONT COLOR="#0000FF">Rescue utility</FONT></U>
<BR>
Implementace je v <A HREF="../striping.cpp">STRIPING.CPP</A>. Ve funkci StripingRescue() se provádí nastavení a záchranu provádí funkce STRIPRescueParty().
<BR>
Pokud jsme pøišli o jednu datovou oblast nic se nedìje. Jsme toti schopni ji z parity a zbylıch datovıch oblastí zrekonstruovat.
<BR>
<BR>
Záchrana jednotlivého sektoru se provádí takto.
<BR>
Naètu si z paritního disku sektor s paritou. Potom jednotlivì naèítám sektory z datovıch oblastí a vdy provádím XOR se sektorem parity. Nakonec mi zbyde v bufferu kde jsem mìl uloenu paritu obsah ztraceného sektoru.
<BR>
<BR>
Záchrana oblasti.
<BR>
Provede se záchrana Boot Recordu. Naète se Boot Record oblasti kam zachraòuji. V tomto boot recordu se zmìní informace jako adresa FNODU root direktoráøe, poèet grup v oblasti, poèet rezervovanıch sektorù na informace zachránìného Boot Recordu. Zbytek se
 ponechá tak jak je a Boot Record se zapíše. Obdobná operace se provede záchrana The Second Boot Recordu. Zbytek oblasti ze zrekonsruuje jak bylo uvedeno v odstavci o záchranì jednoho sektoru.
<BR>
<BR>


<U><FONT COLOR="#0000FF">Ètení a zápis sektorù ve stripovacím módu</FONT></U>
<BR>
Jak ji bylo vıše uvedeno, striping se orientuje na úrovni logickıch sektorù na device. Proto vıbìr toho, která funkce se pouije ( klasická nebo stripovací ) se provádí ve funkci pracující na této úrovni. Všechny vıše postavené moduly volají tuto funkci
 a ta u provede vıbìr za nì. Zde je kód ètecí funkce ( zapisovací je analogická ) z <A HREF="../striping.cpp">STRIPING.CPP</A>, kterı myslím vysvìtlí více ne dlouhı popis.
<BR>
<PRE>
word ReadLogicalSector( byte Device, dword Logical, void far *Buffer, byte Number )
// this function is used by upper level
{
 #ifdef DEBUG
  printf("\n READing sector %lu... ", Logical );
 #endif

 if(
     StripingSession.StripingIs==ACTIVE
     &&
     StripingSession.DataHDs.IsInStripingArea( Device, Logical )
   )
 {
  #ifdef DEBUG
   printf(" STRIPing version...", Logical );
  #endif

  return STRIPReadLogicalSector( Device, Logical, Buffer, Number );
 }
 else
 {
  return CLASSICReadLogicalSector( Device, Logical, Buffer, Number );
 }
}
</PRE>
<BR>
STRIPReadLogicalSector() je tedy funkce, která provádí ètení ve stripovacím módu. Ètení probíhá takto. Naèítají se odpovídající sektory z jednotlivıch datovıch oblastí a poèítá se parita levelù. Nakonec se parita zkontroluje a pøípadnì opraví. Naètená da
ta se nakopírují do bufferu volající funkce.
<BR>
STRIPWriteLogicalSector() provádí zápis. Zápis probíhá takto. Naètou se data z jednotlivıch datovıch oblastí a spoèítá se jejich parita KROMÌ OBLASTI DO KTERÉ BUDU ZAPISOVAT. K paritì se pøipoètou zapisovaná data. Následuje zápis dat a hned po nìm zápis
parity.
<BR>
<BR>
Pro podrobnosti nahlédnìte prosím do zdrojového kódu.
<BR>
<BR>


<U><FONT COLOR="#0000FF">Pár slov k implementaci jako takové</FONT></U>
<BR>
Striping je místo, kde se nejvíce projevilo, e provádíme implementaci našeho file systemu pod DOSem. Pøi implementaci jsem musel velmi šetøit pamìtí a tak jsou pøepoèty dìlány po sektorech ( a tedy velmi hloupì ). Z toho plyne, e záchrany, pøepoèty par
it i bìh je velmi pomalı. Do bufferù se data z jednotlivıch diskù ètou po sobì. Pokud by jsme systém implementovali pod UNIXem forknul by jsem si na kadé ètení jedno vlákno a ètení by probíhalo paralelnì ( tedy tolikrát rychleji ne pøi normálním ètení
kolik je datovıch diskù ( v naší implementaci díky sekvenènosti je ale tolikrát pomalejší )).<U> Na implementaci stripingu se tedy prosím dívejte spíš jako na špatnou implementaci snad dobrıch nápadù, které by jinde mohly bıt implementovány mnohem lépe.
Díky za pochopení.</U>
<BR>
<BR>



<A NAME="AnchorCacheMan"><U><FONT SIZE="+1" COLOR="#0000FF">CacheMan = Cache + Swap, package, konzistentní zápisy</FONT></U></A>
<BR>
<BR>
Naším cílem je zachování konzistence souborù. Proto data se kterımi se bude pracovat zorganizujeme do logickıch celkù - packageù. Zhruba øeèeno, pøi práci s daty souboru RD/WR vyšší vrstva na vlastní ádost získá nìjaké PackageID. Pøi všech dalších opera
cích nad tímto souborem bude pouívat tuto identifikaci. Spodní vrsta tedy bude vìdìt, která data k sobì logicky patøí. Na konci práce se souborem nebo ve chvíli, kdy bude horní vrstva vìdìt, e byla všechna potøebná data "zapsána", zavolá horní vrstva C
ommitPackage( PackageID ). Na to provede spodní vrstva "double write" co je zápis, kterı zaruèuje konzistenci. Ten se provede tak, e se obsah cache zapíše do odkládací oblasti, tato skuteènost se zapíše do logu a následnì se kompletní package nakopíruj
e do cílového souboru.
V pøipadì havárie tedy bude moné operaci dokonèit.
<BR>
<BR>
        Konzistentním zápisùm bylo nutné podøídit pøedevším cacheovací mechanismus. Museli jsme navrhnout cache tak, aby ji vyšší vrstva mìla pøehled o tom CO JE SKUTEÈNÌ ZAPSÁNO NA DISKU A CO JE POUZE V CACHE. CacheMan se skládá ze dvou èástí:
<BR>
(i) pamìová èást: klasická pamìová cache
<BR>
(ii) odkládací èást: pokud dojde pamì v pamìové èásti cache, musí se dirty data odloit na swapovací oblast konzistentních zápisù. Nelze je zapsat pøímo do souboru - nevím toti jestli uivatel zapsal do vše co chtìl.
<BR>
Schema CacheMana:
<BR>
<BR>
<BR>
<CENTER>
<IMG SRC="cacheman.gif" WIDTH=516 HEIGHT=366 BORDER=0>
</CENTER>
<BR>
<BR>
        Pro cacheování jsme si zavedli package. Je to zpùsob jak pøedává horní vrstva cache informaci o tom, e urèitá data k sobì logicky patøí. Díky tomu cache ví, jak má data do souboru zapisovat, aby zùstal v konzistentním stavu.
<BR>
<BR>
        Typicky pøi otevøení souboru zaádá vyšší vrstva o vytvoøení package ( package mùou bıt jemnìjší, tøeba nìkolik na jeden soubor). Vytvoøí se struktury v cache a cache vrátí horní vrstvì èíslo vytvoøeného package. Potom kdykoli ze souboru vyšší v
rstva data ète/zapisuje odkazuje se na nì tímto èíslem. Tato data, buï zústávají v cache nebo se odkládají na swap. Do souboru se uloí a po zavolání
CommitPackage( PackageID ). Tak má vyšší vrstva kontrolu nad tím co je v cache a co je ve skuteènosti na disku.
<BR>
<BR>
        Pracuje se vdy s intervaly sektorù. Operace jsou navreny tak, e package nikdy neobsahuje sektor dvakrát. DOKONCE PLATÍ E V CELÉM CACHEOVACÍM SYSTÉMU MUE BİT SEKTOR NEJVİŠE JEDNOU!. Buï sektor v CacheManovi není, nebo je pouze v cache, nebo j
e pouze na swapu. Nyní popíši jak se postupuje pøi jednotlivıch operacích:
<BR>
<BR>

<A NAME="AnchorCteni"><U><FONT COLOR="#0000FF">Ètení</FONT></U></A>
<BR>
Dostanu èíslo package, ke kterému se ètení vztahuje - PackageID. Vytvoøím si bitmapu pro interval sektorù, kterı ètu ( ètu je do userbufferu ). Bit v bitmapì odpovídá sektoru v userbufferu. Kdykoli naètu sektory, nastavím odpovídající bity na 1. Konèím k
dy jsou všechny bity nastaveny na 1 - všechna data byla naètena.
<BR>
<BR>

<U>Postup:</U>
<BR>
a) prohledám swap. Procházím swap descriptory package PackageID a ètu data do userbufferu a znaèím v bitmapì ( interval sektorù kterı mám naèíst se èásteènì nebo úplnì pøekrıvá s intervalem na swapu ). Poznámka: kdy se data dostala na swap, znamená to 
e jsou dirty - proto s nimi zaèínám. Projdu celou frontu swap deskriptorù package PackageID.
<BR>
<BR>

b) procházím cache. Procházím cache descriptory package PackageID. Pokud se interval sektorù kterı mám naèíst èásteènì nebo úplnì pøekrıvá s intervalem na v cache kopíruji data do userbufferu a znaèím v bitmapì. Projdu celou frontu cache deskriptorù.
<BR>
<BR>

c) pokud ještì chybí nìjaké sektory, natáhnu je pøímo ze souboru.
Pokud je dost pamìti umístím nataená data do cache mojeho package.
<BR>
<BR>

<A NAME="AnchorZapis"><U><FONT COLOR="#0000FF">Zápis</FONT></U></A>
<BR>
Dostanu èíslo package, ke kterému se zápis vztahuje - PackageID. Vytvoøím si bitmapu pro interval sektorù, kterı budu zapisovat. Bit v bitmapì odpovídá sektoru v userbufferu ze kterého zapisuji. Kdykoli zapíši sektory, nastavím odpovídající bity na 1. Ko
nèím kdy jsou všechny bity nastaveny na 1 - všechna data byla zapsáno. ZDE SE DATA ZAPISUJÍ POUZE DO CACHEMANA NE DO SOUBOURU ( TO PROVÁDÍ A COMMIT PACKAGE! )
<BR>
<BR>

<U>Postup:</U>
<BR>
a) prohledám swap package PackageID. Na swapu jsou pouze dirty data, proto je musím pøepsat jako první. Procházím swap descriptory a zapisuji data pøi èásteèném èi úplném pøekrytí intervalù na swap a znaèím v bitmapì.  Projdu celou frontu swap deskriptor
ù.
<BR>
<BR>

b) procházím cache package PackageID. Procházím cache descriptory. Pokud se interval sektorù kterı mám zapsat èásteènì nebo úplnì pøekrıvá s intervalem na v cache, kopíruji data do cache +  v markuji jako dirty + znaèím v bitmapì. Projdu celı frontu cach
e deskriptorù.
<BR>
<BR>

c) pokud ještì chybí nìjaké sektory zkusim:
        (i) pokud je místo v cache - vytvoøím desckriptor, data nakopíruji tam + omarkovaji descr dirty + poznaèím v bitmapì.
        (ii) pokud není místo v cachu zkusím swap. Analogicky.
      (iii) pokud není místo na swapu následuji zápis pøímo do souboru - PORUŠUJE KONZISTENCI.
<BR>
<BR>

<A NAME="AnchorVelikostCache"><U><FONT COLOR="#0000FF">Velikost cache, swapovací oblasti</FONT></U></A>
<BR>
Zde je myslím u celkem vidìt jak systém funguje. Záleí tedy na uivateli jak velkou si zvolí cache a jak velkou odkládací oblast. Èím vìtší budou tyto oblasti tím lépe budou konzistentní zápisy fungovat ( vìtší objem dat, vìtší soubory ). Pokud bude ca
che dostateènì velká, uštøí se ètení ze swapu - systém bude rychlejší.
<BR>
        Vše je tedy na uivateli. Èím bude velkorysejší, tím rychleji a lépe bude vše fungovat.
<BR>
<BR>

<A NAME="AnchorCommit"><U><FONT COLOR="#0000FF">Commit package</FONT></U></A>
<BR>
Provede konzistentní zápis do souboru.
<BR>
a) prochází se cache descriptory package PackageID.
<UL>
<LI>NOTDIRTY poloky se dealokují.</LI>
<LI>DIRTY poloky se ukládají na swap a ponechávají se v pamìti ( pøi jejich zápisu do filu se toti pozdìji UŠETØÍ jeden read - nemusí se èíst ze swapu, ale zapíšou se rovnou z pamìti. Tento postup je korektní, protoe pokude vypadne proud tak se po res
tartu ze swapu doètou... ). Jejich seznam se zapisuje do logu.</LI>
</UL>
Pokud je swapování vypnuto nic se na swap samozøejmì nekopíruje a data se "nekonzistnì zapisují pøímo do souboru".
<BR>
<BR>

b) prochází se swap descriptory package PackageID. Seznam intervalù se pøipíše do logu.
<BR>
<BR>

c) prochází se podruhé swap descriptory a kopíruje se ze swapu do filu, descriptory se následnì dealokují.
<BR>
Pokud dojde v tomto místì k vıpadku proudu nic se nedìje. Po restartu systému se udìlá REDO: podle logu se ze swapu data znovu zkopírují do souboru - KONZISTENCE JE ZARUÈENA ( na swapu jsou nyní ji všechna data - i z cache! ).
<BR>
<BR>

d) prochází se podruhé cache descriptory a data se z cache kopírují do souboru, descriptory se následnì dealokují ( je to korektní a rychlejší - viz. vıše ).
<BR>
<BR>

e) do logu se zapíše COMMIT a logovací file se smae.
<BR>
<BR>

<A NAME="AnchorJineMoznosti"><U><FONT COLOR="#0000FF">Byly tu i jiné monosti...</FONT></U></A>
<BR>
Místo double writes pøicházela ještì druhá monost jak provést konzistentní zápis: zapsat data z cache nìkam do datové oblasti, zapsat to do logu a pak zaèít pøepojovat odkazy na sektory v FNODEu ze starıch na nové aktuální sektory. Pro tuto monost jsem
 se nerozhodl protoe:
<OL>
<LI>Docházelo by k velké fragmentaci dat. Se zaplòováním file systemu by u data nebyla u sebe ( pøipomínám, e horní vrstva si mùe øíci za kterım sektorem chce nové sektory naalokovat, spodní vrstva se potom snaí alokovat co nejblíe tomuto sektoru ),
 nato v té samé grupì. Ve vısledku by to, podle mého názoru, bylo ménì vıkonné ne pomìrnì rychlé <U>souvislé</U> zápisy ( ménì seekování ).</LI>
<LI>Swapovalo by se mezi data</LI>
<LI>Problém by šel mnohem hùøe rozdìlit na horní a spodní vrstvu tak jak je tomu nyní. Spodní vrstva by toti musela hrabat ve strukturách vrstvy horní a vice versa.
</LI>
</OL>
<BR>
<BR>


Funkce CacheMana jsou deklarovány v <A HREF="../cacheman.h">CACHEMAN.H</A>, dále jsou vyuívány funkce podpory cache <A HREF="../cachesup.h">CACHESUP.H</A>, kde jsou deklarace package a reijních struktur...
<BR>
<BR>



<BR>
<CENTER>
<A NAME="AnchorTransakce"><U><FONT SIZE="+1" COLOR="#0000FF">TRANSAKCE a LOGY : *.ALF, *.NOT, *.OKA, *.HLP, *.CML</FONT></U></A>
</CENTER>
Logy jsou páteøí transakèního systému RFS ( jestli mu tak lze øíkat ).
Nejdøíve po jednom popíši jednotlivé logy. Pokud chcete jejich strukturu do podrobna zkoumat nebo Vás zajímá implementace =&gt; nahlédnìte prosím do zdrojákù.  Pozdìji v kapitole o tom co a jak se pomocí logù opravuje vyjasním jejich konkrétní vıznam a v
ìci jako jak se logy vyuívají navzájem a jaké jsou jejich vztahy.
<BR>
<BR>

<A NAME="AnchorALF"><U><FONT COLOR="#0000FF">*.ALF - ALLOC/FREE log</FONT></U></A>
<BR>
Je základním typem logu. Vìtšina ostatních logù na nìm stojí. Jeho vyjímeèností je to, e se v jedné oblasti mùe vyskytovat nejvıše jeden. Je to z dùvodu serializace transakcí. Existence nejvıše jednoho ALF logu mi zaruèuje, e transakèní operace budou
provádìny poøadì.
<BR>
Tento log je pouíván funkcemi CacheManAllocateSector() a CacheManFreeSector(). Tyto funkce volají fci AllocFreeUsingLog() ( <A HREF="../recovery.h">RECOVERY.H</A> ). Tato fce má zásadní vıznam. Provádí toti konzistentní zápis bitmapy. To znamená, e tr
ansakènì pomocí logu ALF provede zmìny ve statistikách a zápis bitmapy tak, aby vše odpovídalo a úspìšnou alokoci rovnì transakènì zaznamená do OKA ( OK Allocated log  - viz. níe ) logu package. ALF record se pøi crash <U>vdy ROLLBACKUJEuje</U> ( Undo
AlfLog() z <A HREF="../recovery.h">RECOVERY.H</A> )=&gt; nikdy se neprovádí redo ( nicménì jeho struktura je navrena tak, e by redo šlo  z informací v nìm obsaenıch provést ). Další dùleitou vlastností ALF logu je, e operace jeho rollbacku je <U>IDE
MPOTENTNÍ</U> tzn. dojde-li v dobì rollbacku ke crash mùe se celá operace rollback provést znovy pøes ji jednou provedenı a vše bude OK.
<BR>
Struktura ALF logu ( pro detaily nahlédnìte do zdrojákù )
<BR>

<PRE>
// Log structure:                                                 Size:  Off:
//
// LOG_BEG_TRANSACTION  ( 0 Alloc, 1 Free )                        8      0
//
//  LOG_BEG_WR_BMP                                                 8      8
//    write_to_log   GroupID                                       4      16
//    write_to_log   Logical                                       4      20
//    write_to_log   LogicalInBmp (0-4095)                         4      24
//    write_to_log   Number                                        2      28
//    write_to_log   Bitmap                                        512    30
//   LOG_CHECKPOINT                                                8      542
//    write_to_party Bitmap                                        ..
//  LOG_COM_WR_BMP                                                 8      550
//
//  LOG_BEG_WR_GRPSTAT                                             8      558
//    write_to_log   OldGrpFreeSpace                               2      566
//   LOG_CHECKPOINT                                                8      568
//    write_to_party NewGrpFreeSpace                               ..
//  LOG_COM_WR_GRPSTAT                                             8      576
//
//  LOG_BEG_WR_SCND_BOOT                                           8      584
//    write_to_log   OldPartyFreeSpace                             4      592
//   LOG_CHECKPOINT                                                8      596
//    write_to_party NewPartyFreeSpace                             ..
//  LOG_COM_WR_SCND_BOOT                                           8      604
//
//  LOG_BEG_WR_OKA                                                 8      612
//    ( call function ... which writes it transactionaly to OKA )  ..
//  LOG_COM_WR_OKA                                                 8      620
//
// LOG_COM_TRANSACTION                                             8      628
//                                                              ---------
//                                                        Total:   636
</PRE>
Vlastností kterou se liší od ostatních logù stejnou strukturou jako je NOT je to, e je vytváøen pouze pro alokace v nìjakém <U>Package</U> ( pøipomínám, e pøi práci s cache se na package odkazuje pøi operacích loadtocache/load/save/alloc/free/commit ).
 Tedy package ID je pozpodmíneènì nutné pro jeho vytvoøení.
<BR>
<BR>



<A NAME="AnchorNOT"><U><FONT COLOR="#0000FF">*.NOT - NOT PackageID Alloc/Free log</FONT></U></A>
<BR>
Tento log má absolutnì stejnou strukturu jako ALF log. Liší se od ALF logu tím, e je vytváøen pøi alokacích mimo package. Pøíkladem pouití takovı alokoací je alokace místa pro logy. Logy jdou mimo cache -&gt; zápisy i ètení z nich se provádìjí pøímo -&
gt; nevyrábí se pro nì package protoe nemá smysl provádìt commit kdy cache nic z nich nesmí obsahovat. Na NOT logu se Vdy provádí operace ROLLBACK, která je IDEMPOTENTNÍ. Rollback se provádí funkcí UndoAlfLog() z <A HREF="../recovery.h">RECOVERY.H</A>
 ).
<BR>
<BR>



<A NAME="AnchorOKA"><U><FONT COLOR="#0000FF">*.OKA - OK Allocated/Released log</FONT></U></A>
<BR>
Log OKA slouí pro evidenci naalokovanıch/uvolnìnıch sektorù toho kterého package. Kadı package má vlastní OKA log. V prùbìhu práce se allokace/dealoakace v package provádìjí pøímo ( neodkládají se ). Pokud dojde ke crash pøed commitem musí bıt takové m
ísto uvedeno do pùvodního stavu. Jak u bylo vıše uvedeno, tyto operace se provádìjí pomocí ALF logu, kterı pøipisuje do OKA logu ty úspìšné. Pøi crash se tedy provede rollback OKA zpìtnou analızou ( podrobnìji níe ) a vše se uvede do pùvodního stavu. V
 rámci commitu se provádí mazání OKA logù - to je ta lepší monost. Uvnitø commitu se v urèité dobì u najisto ví ( viz níe ), e místo bude pouito -> OKA log se mùe smazat. Do OKA logu se pøipisuje nakonec. OKA log se skládá z recordù této struktury:


<PRE>
 typedef struct
 {
  dword  Record_Beg;    // ALLOC_RECORD || FREE+RECORD
   dword  State;        // NORMAL_STATE || ROLLBACKED_STATE
   dword  Logical;
   word   Number;
   dword  GroupID;
   dword  LogicalInBmp;
  dword  Record_End;    // OKA_RECORD_END
 }
 OkaRecord;                     // sizeof()=26
</PRE>
<BR>
Podrobnosti <A HREF="../recovery.cpp">RECOVERY.CPP</A>.
<BR>
<BR>

<A NAME="AnchorHLP"><U><FONT COLOR="#0000FF">*.HLP - HeLP Alloc/Free undo log</FONT></U></A>
<BR>
Tento log má absolutnì stejnou strukturu jako ALF log. Je pouíván pøi rollbacku OKA logu. Jak se provádí rollback OKA logu je popsáno níe.
<BR>
Podrobnosti <A HREF="../recovery.cpp">RECOVERY.CPP</A>.
<BR>
<BR>



<A NAME="AnchorCML"><U><FONT COLOR="#0000FF">*.CML - Commit undo/redo log</FONT></U></A>
<BR>
CML je log, kterı se pouívá pro zajíštìní konzistence commitu urèitého package( pøipomeòte si jak se provádí commit ). Bìhem commitu se do CML uloí, kde je obsah cache na swapu ( urèeno pro double write ), kde je odloen zbytek na swapu ( obsah swap de
scriptorù ). Jakmile se do commitu zapíšou všechny tyto informace, uloí se tam checkpoint, kterı øíká "to byl poslední záznam, teï zaèínám kopírovat ze swapové partyšny na datovou". Ano zde je ta chvíle pro smazání OKA logu. Jakmile se uloí tento check
point, u se bude dìlat po crash vdy REDO -&gt; místo bude kadoupádnì pouito a tak tedy kadopádnì nebudu rollback OKA potøebovat. Pokud dojde ke crash pøed zapsáním magiky provádí se vdy UNDO - nestihl se dostat obsah package/cache do odkládací obla
sti celı - takovı zápis do datové oblasti by nebyl konzistentní.
<BR>
Nyní se vdy podle CML logu naètou data ze swapu, uloí se do datové partyšny a místo na swapu se odalokuje ( ano pomocí ALF logu ). Mám tedy jistoto, e bude vše konzistentní. Provedení jak REDU tak UNDO podle CML logu je IDEMPOTENTNÍ ( Zarazila vás víc
enásobná dealokace na v pøipadì crash pøi opravách - po recovery se provádí pøeformátování swapovacích oblastí. Testy jsem zjistil, e od zaplnìní oblasti kolem pùlky kapacity je to rychlejší ne zvláštní log a dealokace dle nìj ).
<BR>
Struktura CML logu ( <A HREF="../recovery.h">RECOVERY.H</A>):
<PRE>
// Structure of CML record:
//
// TypeOfRecord  // CACHE_INTERVAL || NOT_LAST_RECORD ( SWAP ) || BEGIN COPY
//  Device;             // 0, ..
//  Party;            // 1, ..
//  SwapDevice;
//  SwapParty;
//  Logical;
//  LogicalSwap;
//  Number
//
//
// Structure of CML log file:
//  Type
//   CACHE_INTERVAL     // intervals moved in pack commit from cache to swap
//   ..
//   CACHE_INTERVAL     // intervals moved in pack commit from cache to swap
//   NOT_LAST_RECORD    // intervals in pack commit time on swap
//   ..
//   NOT_LAST_RECORD    // intervals in pack commit time on swap
//   BEGIN_COPY         // checkpoint: all data on swap, begin of copy
//                      // from swap party to data party

</PRE>

<BR>
<BR>

<A NAME="AnchorOpenFs"><U><FONT COLOR="#0000FF">Co se dìje pøi inicializaci RFS</FONT></U></A>
<BR>
Pro otevøení RFS slouí funkce FSOpenFileSystem() z <A HREF="../init.cpp">INIT.CPP</A>.
<BR>
<BR>
<U>Co se dìje pøi startu systému:</U>
<BR>
<BR>
Testuje se zda jsou v systému pøítomné fyzické disky. Fyziké disky se berou popoøadì, na kadém disku se naète MBR, podle nìj se ètou všechny BR, které jsou pouity. V tìchto boot recordech se hledá v BR.OSID.ID magic "RFSData" nebo "RFSSwap". Pokud tam
tento magic je identifikuje se oblast jako oblast našeho file systemu. Oblasti se tøídí do ètyø spojovıch seznamù.
<BR>
<BR>
V prvním jsou RFSData - tj. datové oblasti, které mìly dirty flag nastaven na CLEAN ( ty jsou OK a s tìmi u se nic dìlat nebude)
<BR>
<BR>
Ve druhém jsou RFSData, které mìly dirty flag nastaven na DIRTY - bude se muset provést jejich oprava.
<BR>
<BR>
Ve tøetím jsou RFSSwap, které mìly dirty flag nastaven na CLEAN. Ty jsou v poøádku.
<BR>
<BR>
Ve ètvrtém jsou RFSSwap, které mìly dirty flag nastaven na DIRTY - bude se muset provést jejich oprava.
<BR>
<BR>
Takto se projdou všechna zaøízení pøítomná v systému a naplní se spojové seznamy.
<BR>
<BR>
Nyní se zaène procházet fronta <B>dirty RFSData</B> na kadou takovou oblast se zavolá funkce RecoverParty() z <A HREF="../recovery.cpp">RECOVERY.CPP</A> ( viz. níe ), která provede opravu oblasti. Po opravì se datová oblast pøepojí do spojáku CLEAN dat
ovıch oblastí.
<BR>
<BR>
Takto se zpracuje celı DIRTY spoják datovıch oblastí.
<BR>
<BR>
Nyní se projde fronta <B>dirty RFSSwap</B> a kadá oblast z nìj se zformátuje. Data, která na nich byla u z nich dostala funkce RecoverParty(). Nyní se tedy pouze musejí proèisti a rychlı formát je tou nejefektivnìjší metodou. Po pøeformátování se odklá
dací oblast pøepojí do spojáku CLEAN odkládacích oblastí.
<BR>
<BR>
Takto se zpracuje celı DIRTY spoják odkládacích oblastí.
<BR>
<BR>
V dalším kroku se provede nastavení dirty flagu všem oblastem ( které jsou nyní u pouze ve dvou CLEAN spojácích ).
<BR>
<BR>
Provede se nahození CacheMana
<BR>
<BR>
<BR>



<A NAME="AnchorRecovery"><U><FONT COLOR="#0000FF">RECOVERY aneb jak se opravuje pomocí logù po pádu systému</FONT></U></A>
<BR>
Implementace všeho o èem zde budu psát je v <A HREF="../recovery.cpp">RECOVERY.CPP</A>.
<BR>
<BR>
V této kapitole dokumentace popíši co se zaène dít, kdy se po restartu systému zjistí, e oblast je dirty a je ji tedy tøeba uvést do konzistentního stavu uitím logù. Tento úkol plní funkce <B>RecoverParty()</B>.
<BR>
<BR>
<U>Co recovery v jedné oblasti dìlá:</U>
<UL>
 <LI>
 Jako první se vyhledají všechny <B>*.HLP logy</B> ( které mají stejnou strukturu jako *.ALF ). Tyto logy se generují, kdy se provádí rollback OKA logu. HLP log se vytvoøí a musí bıt kompletní. Po jeho kompletním vygenerování se pøejmenuje na *.ALF a za
volá se na nìj funkce UndoAlfLog() z <A HREF="../recovery.cpp">RECOVERY.CPP</A> ) , která provede rollback jednoho OKA recordu z *.OKA logu ( to vše se provádí v rámci rollbacku OKA filu - NE NYNÍ - vyjasòuji pouze situaci vzniku HLP logu ). Zde se <B>vš
echny HLP logy smaou</B>. Mohu to udìlat protoe budou v pozdìjší fázi recovery vygenerovány znovu. Ještì bych rád ujasnil, e pokud nìkde zùstane HLP log, znamená to e byl sice vygenerován, ale nebyl pøejmenován a nemohlo se tedy ani zaèít s jeho roll
backem - nièeho se nemusím bát kdy ho mau.
 </LI>

 <LI>
Nyní se vyhledávají <B>*.NOT logy</B>. Tyto logy jsou pouívány funkcemi pro alokaci a uvolòování sektorù operací, které nejsou cacheovány. Pouívají se napøíklad pøi práci s logy a s odkládacími oblastmi. Swap je na konci recovery naformátován take o t
en se nemusím starat. Ale misto alokované/uvonìné v datové oblasti musí bıt uvedeno do pùvodního stavu - <B>provede se tedy rollback NOT logu</B>. Protoe nebyla šance, jak zmìnu zaevidovat v FNODEu, protoe ne se operace skonèila systém se sloil. Kdyb
y jsem rollback neprovedl vzniky by mi ztracené sektory, které by nikomu nepatøily nebo naopak obsazené sektory, které by byly v bitmapì oznaèeny jako prázdné.
 </LI>

 <LI>
Následuje vyhledání <B>*.ALF logù</B> jejich rollback a probublání skrz nì do jejich OKA filu ( z kterého byly volány ). Pøi rollbacku ALF file probublá do OKA a tam oznaèí sobì odpovídající record jako rollbacked. Vše se provádí tak, aby v pøípadì, e d
ojde ke crash nyní v dobì opravy se mohlo vše dokonèit ( idempotence rollbacku ALF logu je známa ). Rollback ALF logù uvádí do konzistentního stavu ostatní log fily. Tím je myšleno to, e u v nich nejsou zlomky nìjakıch recordù, ale recordy celé - recor
dy jsou v nich buï typu commited nebo rollbacked.
 </LI>

 <LI>
Na øadì je oprava pomocí <B>CML logù</B>. Ty se vytváøejí v prùbìhu commitu jak bylo popsáno vıše. Opravu pomocí CML logù provádí RecoverUsingCml() z <A HREF="../recovery.cpp">RECOVERY.CPP</A>
<BR>
(i) pokud CML obsahuje magic BEGIN_COPY - provede se redo ( pokud došlo nìkdy døíve ke crash bìhem této opravy mùe se stát, e se udìlá nìkterá z operací na swapu dvakrát, ale to nevadí , protoe swap se v zápìtí reformátuje ). OKA log tohoto package se
 smae ( pokud se tak ji nestalo, protoe je jistota, e místo na swapu bude pouito ).
<BR>
(ii) pokud CML magic BEGIN_COPY neobsahuje - musí se provést undo. To znamená, e CML se smae. Protoe nìkterá data jsou na swapu a nìkterá ne a swap se reformátuje. Musí se však provést rollback OKA logu odpovídajícího package, protoe by v datové obla
sti zùstalo místo na které se se volalo alloc/free a nebude vyuito.
<BR>
</LI>

<LI>
Teï u zbyly v oblasti pouze <B>OKA logy</B>. Na tyto OKA logy musí bıt provedena operace ROLLBACK. Tu provádí funkce RollbackOkaLog() z <A HREF="../recovery.cpp">RECOVERY.CPP</A>. Ta funguje takto:
<BR>
Poslední záznam v OKA logu nemusí bıt analyzován, protoe byl oznaèen jako ROLLBACKED pøi undo korespondujícího ALF logu. Zbıvá tedy analyzovat zbıvající, ji kompletní recordy OKA logu. Recordy se ètou od zadu logu smìrem k poèátku. Pro kadı record se
vygeneruje ALF log. To se udìlá tímto zpùsobem: nejdøíve se vygeneruje HLP log funkcí GenerateHlpLog() z <A HREF="../recovery.cpp">RECOVERY.CPP</A>. kterı je potom pøejmenován na *.ALF. Je to udìláno takto protoe chci aby ALF byl vdy kompletní. Jestliz
e se system sloí pøed rename - HLP file se smae. Jestlie, se systém sloí po rename vím, e recovery ALF zpracuje jako první, dále vím, e v oblasti mùe bıt nejvıše jeden ALF log ( ten mùj ) a také vím, e provedení rollbacku nad logem ALF je idempot
entní -&gt; vše je OK, po crash lze vklidu pokraèovat v rollbacku.
<BR>
Zpìt ke zpracovávání recordù. Record se naète, podívám se na magic: jestlie je rollbacknutı, vezmu naètu pøedchozí, jestli e je NORMAL zpracuji ho. Jestlie je typu ALLOC vygeneruji alloc HLP log, jestlie je typu FREE vygeneruji free HLP log. Pøejmenu
ji HLP log na ALF. Zavolám UndoAlfLog() která provede rollback za mì. Oznaèím record v OKA jako rollbacked. Smau OKA log.
</LI>

</UL>
<B>Recovery práce jsou hotovy =&gt; oblast je opravena...</B>
<BR>
<BR>
<BR>



<A NAME="AnchorShutdownFs"><U><FONT COLOR="#0000FF">Co se dìje pøi zavírání RFS</FONT></U></A>
<BR>
Pro uzavøení RFS slouí funkce FSShutdownFileSystem() z <A HREF="../init.cpp">INIT.CPP</A>.  Tato funkce nejdøíve provede kompletní commit cache a tím dokonèí všechny transakce. Potom projde jak spojík datovıch oblastí tak spoják odkládacích oblastí a vš
em oblastem nastaví dirty flag na CLEAN, kterı znamená, e oblasti byly odpojeny korektním zpùsobem.
<BR>
<BR>

</FONT>
</BODY>
</HTML>
